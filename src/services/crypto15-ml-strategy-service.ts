/**
 * Crypto15MLStrategyService
 *
 * Main orchestration service for the 15-minute binary crypto market strategy.
 * Discovers markets, ingests prices, computes features, generates signals,
 * and executes trades.
 *
 * Key responsibilities:
 * - Load trained models and imputations on startup
 * - Subscribe to real-time crypto price feeds (BTC, ETH, SOL, XRP)
 * - Implement hybrid market discovery:
 *   - Predictive scanning: Pre-create trackers for upcoming markets (every 10 min)
 *   - Reactive scanning: Discover active markets (every 1 min)
 * - Maintain Crypto15FeatureEngine instances per market
 * - Ingest prices and compute features at minute boundaries
 * - Generate signals when conditions are met
 * - Execute market orders via TradingService
 * - Emit events: 'signal', 'execution', 'error', 'marketAdded', 'marketRemoved'
 * - Cleanup stale trackers (every 30 seconds)
 *
 * Part of #6
 */

import { EventEmitter } from 'events';
import { resolve, normalize } from 'path';
import {
  Crypto15FeatureEngine,
  type CryptoAsset,
  type FeatureVector,
} from '../strategies/crypto15-feature-engine.js';
import { Crypto15LRModel } from '../strategies/crypto15-lr-model.js';
import { loadModelsWithImputations } from '../strategies/model-loader.js';
import {
  createCrypto15MLLogger,
  LogEvents,
  StrategyLogger,
  type IStrategyLogger,
} from '../utils/strategy-logger.js';
import type { MarketService } from './market-service.js';
import type { TradingService, OrderResult } from './trading-service.js';
import type { RealtimeServiceV2, CryptoPrice, Subscription } from './realtime-service-v2.js';
import type { GammaMarket } from '../clients/gamma-api.js';
import type { UnifiedMarket } from '../core/types.js';
import type { ITradeRepository, TradeRecord, TradeOutcome, PersistenceConfig, MinutePrice } from '../types/trade-record.types.js';

// ============================================================================
// Types
// ============================================================================

/**
 * Error category for filtering and classification in logs
 */
type ErrorCategory = 'websocket' | 'network' | 'rate_limit' | 'model' | 'feature' | 'general' | 'unknown';

/**
 * Configuration for Crypto15MLStrategyService
 */
export interface Crypto15MLConfig {
  /** Enable or disable the strategy */
  enabled: boolean;
  /** Path to the model JSON file */
  modelPath: string;
  /** Path to the imputation JSON file */
  imputationPath: string;
  /** State minutes when signals can be generated (default: [0, 1, 2]) */
  stateMinutes: number[];
  /** Horizon in minutes for the strategy (default: 15) */
  horizonMinutes: number;
  /** Probability threshold for YES signal (default: 0.70) */
  yesThreshold: number;
  /** Probability threshold for NO signal (default: 0.30) */
  noThreshold: number;
  /** Maximum entry price (default: 0.70) */
  entryPriceCap: number;
  /** Position size in USD (default: 100.0) */
  positionSizeUsd: number;
  /** Symbols to track (e.g., ['BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'XRPUSDT']) */
  symbols: string[];
  /** Threshold in basis points per symbol for up/down detection */
  thresholdBps: Record<string, number>;
  /** Enable debug logging */
  debug?: boolean;
  /** Dry run mode - generate signals but don't execute trades */
  dryRun?: boolean;
  /** Optional logger instance for dependency injection (useful for testing) */
  logger?: IStrategyLogger;
  /** Persistence configuration for trade recording */
  persistence?: PersistenceConfig;
}

/**
 * Signal generated by the strategy
 */
export interface Signal {
  /** Market condition ID */
  conditionId: string;
  /** Market slug */
  slug: string;
  /** Crypto asset symbol (BTC, ETH, SOL, XRP) */
  asset: CryptoAsset;
  /** Signal direction */
  side: 'YES' | 'NO';
  /** Model probability (0-1) */
  probability: number;
  /** Linear combination (z-score before sigmoid) */
  linearCombination: number;
  /** Number of features that were imputed */
  imputedCount: number;
  /** Current market price for the signal side */
  entryPrice: number;
  /** State minute when signal was generated (0-14) */
  stateMinute: number;
  /** Timestamp when signal was generated */
  timestamp: number;
  /** Feature vector used for prediction */
  features: FeatureVector;
}

/**
 * Execution result for a signal
 */
export interface ExecutionResult {
  /** The signal that was executed */
  signal: Signal;
  /** Order result from TradingService */
  orderResult: OrderResult;
  /** Timestamp of execution */
  timestamp: number;
}

/**
 * Paper position for dry-run mode tracking
 */
export interface PaperPosition {
  /** Market ID */
  marketId: string;
  /** Market slug */
  slug: string;
  /** Crypto asset symbol (BTC, ETH, SOL, XRP) */
  symbol: CryptoAsset;
  /** Position side */
  side: 'YES' | 'NO';
  /** Entry price (0-1) */
  entryPrice: number;
  /** Position size in USD */
  size: number;
  /** Model confidence (0-1) */
  confidence: number;
  /** When position was opened */
  timestamp: Date;
}

/**
 * Paper settlement result when market resolves
 */
export interface PaperSettlement {
  /** The paper position that was settled */
  position: PaperPosition;
  /** Market outcome: 'UP' (YES wins) or 'DOWN' (NO wins) */
  outcome: 'UP' | 'DOWN';
  /** Whether the position won */
  won: boolean;
  /** Realized P&L in USD */
  pnl: number;
  /** When the settlement occurred */
  timestamp: Date;
}

/**
 * Paper trading statistics snapshot
 */
export interface PaperTradingStats {
  /** Number of open paper positions */
  positionCount: number;
  /** Cumulative realized P&L in USD */
  cumulativePnL: number;
  /** Snapshot of current open positions (copy, not live reference) */
  positions: PaperPosition[];
}

/**
 * Token lookup result for YES/NO tokens
 */
interface TokenLookupResult {
  yes: { tokenId: string; price: number } | undefined;
  no: { tokenId: string; price: number } | undefined;
}

/**
 * Market tracker maintaining state for each active market
 */
interface MarketTracker {
  /** Market condition ID */
  conditionId: string;
  /** Market slug */
  slug: string;
  /** Crypto asset (BTC, ETH, SOL, XRP) */
  asset: CryptoAsset;
  /** Binance symbol (e.g., BTCUSDT) */
  symbol: string;
  /** Feature engine instance */
  featureEngine: Crypto15FeatureEngine;
  /** Market end timestamp (ms) */
  endTime: number;
  /** Token IDs for YES and NO outcomes */
  tokenIds: { yes: string; no: string };
  /** Current prices */
  prices: { yes: number; no: number };
  /** Whether we've already traded this market */
  traded: boolean;
  /** When this tracker was created */
  createdAt: number;
  /** Minute-level prices recorded during window, keyed by minuteOffset (0-14) for O(1) lookup */
  minutePrices: Map<number, MinutePrice>;
  /** Database trade ID (set after persistence, used for recording minute prices) */
  tradeId?: number;
}

/**
 * Information about a market tracker (public view)
 */
export interface TrackerInfo {
  conditionId: string;
  slug: string;
  asset: CryptoAsset;
  endTime: number;
  traded: boolean;
}

/**
 * Event payload for marketAdded event
 */
export interface MarketAddedEvent {
  conditionId: string;
  slug: string;
  asset: CryptoAsset;
  endTime: number;
}

/**
 * Event payload for marketRemoved event
 */
export interface MarketRemovedEvent {
  conditionId: string;
  slug: string;
  asset: CryptoAsset;
  traded: boolean;
}

/**
 * Typed events emitted by Crypto15MLStrategyService
 */
export interface Crypto15MLStrategyEvents {
  signal: [Signal];
  execution: [ExecutionResult];
  error: [Error];
  marketAdded: [MarketAddedEvent];
  marketRemoved: [MarketRemovedEvent];
  /** Emitted when a paper position is recorded in dry-run mode */
  paperPosition: [PaperPosition];
  /** Emitted when a paper position is settled (market resolved) in dry-run mode */
  paperSettlement: [PaperSettlement];
}

/**
 * Valid CryptoAsset values for validation
 */
const VALID_ASSETS: readonly CryptoAsset[] = ['BTC', 'ETH', 'SOL', 'XRP'] as const;

// ============================================================================
// Constants
// ============================================================================

/** Window duration in minutes */
const WINDOW_MINUTES = 15;

/** Window duration in milliseconds */
const WINDOW_MS = WINDOW_MINUTES * 60 * 1000;

/** Maximum minute offset (0-indexed, so 14 for 15-minute window) */
const MAX_MINUTE_OFFSET = WINDOW_MINUTES - 1;

/** Predictive scan interval (10 minutes) */
const PREDICTIVE_SCAN_INTERVAL_MS = 10 * 60 * 1000;

/** Reactive scan interval (1 minute) */
const REACTIVE_SCAN_INTERVAL_MS = 1 * 60 * 1000;

/** Cleanup interval (30 seconds) */
const CLEANUP_INTERVAL_MS = 30 * 1000;

/** Lookahead time for predictive scanning (30 minutes) */
const PREDICTIVE_LOOKAHEAD_MS = 30 * 60 * 1000;

/** Supported coins */
const SUPPORTED_COINS = ['btc', 'eth', 'sol', 'xrp'] as const;

/** Coin to asset mapping */
const COIN_TO_ASSET: Record<string, CryptoAsset> = {
  btc: 'BTC',
  eth: 'ETH',
  sol: 'SOL',
  xrp: 'XRP',
};

/** Symbol to asset mapping */
const SYMBOL_TO_ASSET: Record<string, CryptoAsset> = {
  BTCUSDT: 'BTC',
  ETHUSDT: 'ETH',
  SOLUSDT: 'SOL',
  XRPUSDT: 'XRP',
};

/** Asset to symbol mapping */
const ASSET_TO_SYMBOL: Record<CryptoAsset, string> = {
  BTC: 'BTCUSDT',
  ETH: 'ETHUSDT',
  SOL: 'SOLUSDT',
  XRP: 'XRPUSDT',
};

/** Maximum reasonable crypto price for validation (prevents extreme outliers) */
const MAX_REASONABLE_PRICE: Record<CryptoAsset, number> = {
  BTC: 1_000_000, // $1M max for BTC
  ETH: 100_000,   // $100K max for ETH
  SOL: 10_000,    // $10K max for SOL
  XRP: 1_000,     // $1K max for XRP
};

/** Allowed base directory for model files */
const ALLOWED_MODEL_DIR = resolve(process.cwd(), 'models');

/**
 * Type guard for CryptoAsset
 */
function isCryptoAsset(value: string): value is CryptoAsset {
  return (VALID_ASSETS as readonly string[]).includes(value);
}

/**
 * Check if an error is transient and should allow retry
 */
function isTransientError(error: unknown): boolean {
  if (!(error instanceof Error)) return false;
  const msg = error.message.toLowerCase();
  return (
    msg.includes('timeout') ||
    msg.includes('network') ||
    msg.includes('econnreset') ||
    msg.includes('econnrefused') ||
    msg.includes('rate limit') ||
    msg.includes('503') ||
    msg.includes('502')
  );
}

// ============================================================================
// Crypto15MLStrategyService Implementation
// ============================================================================

/**
 * Declaration merging for typed EventEmitter
 */
export declare interface Crypto15MLStrategyService {
  on<K extends keyof Crypto15MLStrategyEvents>(
    event: K,
    listener: (...args: Crypto15MLStrategyEvents[K]) => void
  ): this;
  emit<K extends keyof Crypto15MLStrategyEvents>(
    event: K,
    ...args: Crypto15MLStrategyEvents[K]
  ): boolean;
}

export class Crypto15MLStrategyService extends EventEmitter {
  private config: Crypto15MLConfig;
  private models: Map<string, Crypto15LRModel> = new Map();
  private trackers: Map<string, MarketTracker> = new Map();

  /** Secondary index: slug -> conditionId for O(1) lookup */
  private trackersBySlug: Map<string, string> = new Map();

  /** Secondary index: symbol -> Set<conditionId> for O(1) price routing */
  private trackersBySymbol: Map<string, Set<string>> = new Map();

  private priceSubscription: Subscription | null = null;
  private marketEventSubscription: Subscription | null = null;
  private predictiveScanInterval: ReturnType<typeof setInterval> | null = null;
  private reactiveScanInterval: ReturnType<typeof setInterval> | null = null;
  private cleanupInterval: ReturnType<typeof setInterval> | null = null;

  /** Paper positions for dry-run mode (marketId -> PaperPosition) */
  private paperPositions: Map<string, PaperPosition> = new Map();

  /** Cumulative paper P&L for dry-run mode */
  private paperPnL = 0;

  /** Trade repository for persistence (injected via constructor) */
  private tradeRepository: ITradeRepository | null = null;

  /** Set of conditionIds that have been successfully persisted */
  private persistedTrades: Set<string> = new Set();

  private running = false;

  /** Structured JSON logger for Railway-compatible logging */
  private readonly logger: IStrategyLogger;

  constructor(
    private marketService: MarketService,
    private tradingService: TradingService,
    private realtimeService: RealtimeServiceV2,
    config: Crypto15MLConfig,
    tradeRepository?: ITradeRepository
  ) {
    super();

    // Increase max listeners to avoid warnings with multiple consumers
    this.setMaxListeners(50);

    // Validate configuration
    this.validateConfig(config);

    // Deep copy config to prevent external mutation
    this.config = {
      ...config,
      stateMinutes: [...config.stateMinutes],
      symbols: [...config.symbols],
      thresholdBps: { ...config.thresholdBps },
    };

    // Use injected logger or create default (enabled when debug is true)
    this.logger = config.logger ?? createCrypto15MLLogger({
      enabled: config.debug ?? false,
    });

    // Pre-allocate trackersBySymbol Sets for configured symbols
    for (const symbol of this.config.symbols) {
      this.trackersBySymbol.set(symbol, new Set());
    }

    // Store injected trade repository (if provided)
    this.tradeRepository = tradeRepository ?? null;
  }

  /**
   * Validate configuration parameters
   */
  private validateConfig(config: Crypto15MLConfig): void {
    if (config.positionSizeUsd <= 0) {
      throw new Error('positionSizeUsd must be positive');
    }
    if (config.yesThreshold < 0 || config.yesThreshold > 1) {
      throw new Error('yesThreshold must be between 0 and 1');
    }
    if (config.noThreshold < 0 || config.noThreshold > 1) {
      throw new Error('noThreshold must be between 0 and 1');
    }
    if (config.noThreshold >= config.yesThreshold) {
      throw new Error('noThreshold must be less than yesThreshold');
    }
    if (config.entryPriceCap < 0 || config.entryPriceCap > 1) {
      throw new Error('entryPriceCap must be between 0 and 1');
    }
    if (config.stateMinutes.some(m => m < 0 || m > MAX_MINUTE_OFFSET)) {
      throw new Error('stateMinutes values must be between 0 and 14');
    }
    if (config.symbols.length === 0) {
      throw new Error('symbols array cannot be empty');
    }

    // Validate model paths are within allowed directory (prevent path traversal)
    this.validateModelPath(config.modelPath, 'modelPath');
    this.validateModelPath(config.imputationPath, 'imputationPath');

    // Validate thresholdBps contains values for all configured symbols
    for (const symbol of config.symbols) {
      const asset = SYMBOL_TO_ASSET[symbol];
      if (!asset) {
        throw new Error(`Unknown symbol: ${symbol}`);
      }
      if (typeof config.thresholdBps[asset] !== 'number') {
        throw new Error(`Missing thresholdBps for asset ${asset} (symbol ${symbol})`);
      }
      if (config.thresholdBps[asset] <= 0) {
        throw new Error(`thresholdBps for ${asset} must be positive`);
      }
    }
  }

  /**
   * Validate that a model path is within the allowed directory
   */
  private validateModelPath(filePath: string, fieldName: string): void {
    const normalizedPath = normalize(filePath);
    const resolvedPath = resolve(filePath);

    // Check for path traversal attempts
    if (normalizedPath.includes('..')) {
      throw new Error(`${fieldName} contains path traversal (..)`);
    }

    // Check that path is within allowed directory
    if (!resolvedPath.startsWith(ALLOWED_MODEL_DIR)) {
      throw new Error(`${fieldName} must be within ${ALLOWED_MODEL_DIR}`);
    }
  }

  // ============================================================================
  // Lifecycle Methods
  // ============================================================================

  /**
   * Start the strategy service
   *
   * - Requires realtimeService to be connected
   * - Loads models from JSON files
   * - Subscribes to crypto price feeds
   * - Starts predictive and reactive market scanning
   * - Starts cleanup interval
   */
  async start(): Promise<void> {
    if (this.running) {
      return;
    }

    if (!this.config.enabled) {
      return;
    }

    // Require realtimeService to be connected before starting
    if (!this.realtimeService.isConnected()) {
      throw new Error('RealtimeService must be connected before starting Crypto15MLStrategyService');
    }

    try {
      // Load models with imputations
      this.models = await loadModelsWithImputations(
        this.config.modelPath,
        this.config.imputationPath
      );

      this.logger.info(LogEvents.MODELS_LOADED, {
        message: `Loaded ${this.models.size} models`,
        modelCount: this.models.size,
      });

      // Initialize trade repository if provided and persistence is enabled
      if (this.tradeRepository && this.config.persistence?.enabled !== false) {
        await this.tradeRepository.initialize();
        this.logger.info(LogEvents.REPOSITORY_INITIALIZED, {
          message: 'Trade repository initialized',
          dbPath: this.config.persistence?.dbPath ?? './data/crypto15ml/trades.db',
        });
      }

      // Subscribe to price updates
      this.subscribeToPriceUpdates();

      // Subscribe to market resolutions for paper trading (dry-run mode only)
      if (this.config.dryRun) {
        this.subscribeToMarketResolutions();
      }

      // Run initial scans
      await this.scanUpcomingMarkets();
      await this.scanActiveMarkets();

      // Start periodic scanning
      this.predictiveScanInterval = setInterval(
        () => this.scanUpcomingMarkets().catch(e => this.handleError(e)),
        PREDICTIVE_SCAN_INTERVAL_MS
      );

      this.reactiveScanInterval = setInterval(
        () => this.scanActiveMarkets().catch(e => this.handleError(e)),
        REACTIVE_SCAN_INTERVAL_MS
      );

      // Start cleanup interval
      this.cleanupInterval = setInterval(
        () => this.cleanupStaleTrackers(),
        CLEANUP_INTERVAL_MS
      );

      this.running = true;

      this.logger.info(LogEvents.STRATEGY_STARTED, {
        dryRun: this.config.dryRun ?? false,
        trackerCount: this.trackers.size,
        message: this.config.dryRun
          ? 'Strategy started in dry-run mode (no real trades)'
          : 'Strategy started successfully',
      });
    } catch (error) {
      // Cleanup any partially initialized resources
      this.cleanupOnStartFailure();
      this.handleError(error);
      throw error;
    }
  }

  /**
   * Cleanup resources when start() fails partway through
   */
  private cleanupOnStartFailure(): void {
    if (this.priceSubscription) {
      this.priceSubscription.unsubscribe();
      this.priceSubscription = null;
    }
    if (this.marketEventSubscription) {
      this.marketEventSubscription.unsubscribe();
      this.marketEventSubscription = null;
    }
    if (this.predictiveScanInterval) {
      clearInterval(this.predictiveScanInterval);
      this.predictiveScanInterval = null;
    }
    if (this.reactiveScanInterval) {
      clearInterval(this.reactiveScanInterval);
      this.reactiveScanInterval = null;
    }
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
    this.models.clear();
    this.trackers.clear();
    this.trackersBySlug.clear();
    this.paperPositions.clear();
    this.paperPnL = 0;
    // Don't clear trackersBySymbol - it was pre-allocated in constructor
  }

  /**
   * Stop the strategy service
   *
   * - Unsubscribes from price feeds
   * - Clears all intervals
   * - Clears trackers
   */
  stop(): void {
    if (!this.running) {
      return;
    }

    // Log paper trading summary if in dry-run mode
    if (this.config.dryRun) {
      this.logger.info(LogEvents.STRATEGY_STOPPED, {
        dryRun: true,
        positionCount: this.paperPositions.size,
        pnl: this.paperPnL,
        message: `Final stats: ${this.paperPositions.size} open positions, cumulative P&L: ${this.formatPnL(this.paperPnL)}`,
      });
    } else {
      this.logger.info(LogEvents.STRATEGY_STOPPED, {
        dryRun: false,
        trackerCount: this.trackers.size,
      });
    }

    // Unsubscribe from prices
    if (this.priceSubscription) {
      this.priceSubscription.unsubscribe();
      this.priceSubscription = null;
    }

    // Unsubscribe from market events (paper trading)
    if (this.marketEventSubscription) {
      this.marketEventSubscription.unsubscribe();
      this.marketEventSubscription = null;
    }

    // Clear intervals
    if (this.predictiveScanInterval) {
      clearInterval(this.predictiveScanInterval);
      this.predictiveScanInterval = null;
    }
    if (this.reactiveScanInterval) {
      clearInterval(this.reactiveScanInterval);
      this.reactiveScanInterval = null;
    }
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }

    // Clear trackers and secondary indexes
    this.trackers.clear();
    this.trackersBySlug.clear();
    this.trackersBySymbol.clear();

    // Clear paper trading state
    this.paperPositions.clear();
    this.paperPnL = 0;

    // Clear persisted trades set
    this.persistedTrades.clear();

    // Close trade repository (fire-and-forget, errors logged internally)
    if (this.tradeRepository) {
      this.tradeRepository.close().catch((error) => {
        this.logger.error(LogEvents.PERSISTENCE_ERROR, {
          error: error instanceof Error ? error.message : String(error),
          message: 'Failed to close trade repository',
        });
      });
    }

    this.running = false;
  }

  /**
   * Check if the service is running
   */
  isRunning(): boolean {
    return this.running;
  }

  /**
   * Get the number of active market trackers
   */
  getTrackerCount(): number {
    return this.trackers.size;
  }

  /**
   * Get information about all active trackers
   */
  getTrackers(): TrackerInfo[] {
    return Array.from(this.trackers.values()).map(t => ({
      conditionId: t.conditionId,
      slug: t.slug,
      asset: t.asset,
      endTime: t.endTime,
      traded: t.traded,
    }));
  }

  // ============================================================================
  // Market Discovery
  // ============================================================================

  /**
   * Predictive scanning: Generate slugs for upcoming markets and check if they exist
   *
   * Runs every 10 minutes with 30-minute lookahead.
   * Market slug pattern: {coin}-updown-15m-{timestamp}
   * Example: btc-updown-15m-1767456000
   */
  async scanUpcomingMarkets(): Promise<void> {
    const now = Date.now();
    const currentWindowStart = Math.floor(now / WINDOW_MS) * WINDOW_MS;

    // Calculate number of windows based on lookahead constant
    const windowCount = Math.ceil(PREDICTIVE_LOOKAHEAD_MS / WINDOW_MS);
    const windowsToCheck = Array.from(
      { length: windowCount },
      (_, i) => currentWindowStart + WINDOW_MS * i
    );

    // Build list of slugs to check (excluding already tracked)
    const slugsToCheck: string[] = [];
    for (const windowStartMs of windowsToCheck) {
      const windowStartSec = Math.floor(windowStartMs / 1000);
      for (const coin of SUPPORTED_COINS) {
        const slug = `${coin}-updown-15m-${windowStartSec}`;
        if (!this.hasTrackerForSlug(slug)) {
          slugsToCheck.push(slug);
        }
      }
    }

    if (slugsToCheck.length === 0) {
      return;
    }

    // Parallelize API calls for better performance
    const results = await Promise.allSettled(
      slugsToCheck.map(async (slug) => {
        const unifiedMarket = await this.marketService.getMarket(slug);
        return { slug, unifiedMarket };
      })
    );

    // Process results - pass UnifiedMarket directly to avoid redundant API call
    for (const result of results) {
      if (result.status === 'fulfilled') {
        const { unifiedMarket } = result.value;
        if (unifiedMarket && unifiedMarket.active && !unifiedMarket.closed) {
          await this.addMarketTrackerFromUnified(unifiedMarket);
        }
      }
      // Market doesn't exist yet for future windows - this is expected behavior
    }
  }

  /**
   * Reactive scanning: Use MarketService to discover active crypto 15m markets
   *
   * Runs every 1 minute as a safety net to catch any markets missed by predictive scan.
   */
  async scanActiveMarkets(): Promise<void> {
    try {
      const markets = await this.marketService.scanCryptoShortTermMarkets({
        minMinutesUntilEnd: 1,
        maxMinutesUntilEnd: 15,
        duration: '15m',
        coin: 'all',
        limit: 50,
      });

      for (const market of markets) {
        // Skip if we already have this tracker
        if (this.trackers.has(market.conditionId)) {
          continue;
        }

        // Verify it's a 15m market by checking slug pattern
        if (this.is15mMarket(market.slug)) {
          await this.addMarketTracker(market);
        }
      }
    } catch (error) {
      this.handleError(error);
    }
  }

  /**
   * Add a market tracker for a discovered market (from GammaMarket)
   *
   * Fetches complete market data via MarketService and delegates to addMarketTrackerFromUnified.
   * Used by scanActiveMarkets which receives GammaMarket from the API.
   */
  private async addMarketTracker(market: GammaMarket): Promise<void> {
    // Fetch full market data with token IDs
    let unifiedMarket: UnifiedMarket;
    try {
      unifiedMarket = await this.marketService.getMarket(market.conditionId);
    } catch {
      return; // Could not fetch full market data - skip this market
    }

    await this.addMarketTrackerFromUnified(unifiedMarket);
  }

  /**
   * Add a market tracker from UnifiedMarket data
   *
   * Core implementation that creates and registers a tracker.
   * Used directly by scanUpcomingMarkets to avoid redundant API calls.
   * Thread-safe: checks for duplicates before adding to prevent race conditions.
   */
  private async addMarketTrackerFromUnified(unifiedMarket: UnifiedMarket): Promise<void> {
    // Check for duplicate tracker (race condition prevention for parallel discovery)
    if (this.trackers.has(unifiedMarket.conditionId)) {
      return; // Already tracking this market
    }

    const asset = this.inferAssetFromSlug(unifiedMarket.slug);
    if (!asset) {
      return; // Could not infer asset from slug
    }

    const symbol = ASSET_TO_SYMBOL[asset];
    if (!this.config.symbols.includes(symbol)) {
      return; // Symbol not in configured symbols
    }

    // Find tokens by outcome name using helper method
    if (!unifiedMarket.tokens || unifiedMarket.tokens.length < 2) {
      return; // Market does not have required tokens
    }

    const tokens = this.findTokensByOutcome(unifiedMarket.tokens);
    if (!tokens.yes || !tokens.no) {
      return; // Could not get token IDs for market
    }

    // Validate endDate exists
    const endTime = unifiedMarket.endDate?.getTime();
    if (!endTime || endTime <= Date.now()) {
      return; // Market has invalid or past endDate
    }

    const tracker: MarketTracker = {
      conditionId: unifiedMarket.conditionId,
      slug: unifiedMarket.slug,
      asset,
      symbol,
      featureEngine: new Crypto15FeatureEngine(asset),
      endTime,
      tokenIds: { yes: tokens.yes.tokenId, no: tokens.no.tokenId },
      prices: {
        yes: tokens.yes.price,
        no: tokens.no.price,
      },
      traded: false,
      createdAt: Date.now(),
      minutePrices: new Map(),
    };

    // Add to primary map
    this.trackers.set(unifiedMarket.conditionId, tracker);

    // Maintain secondary indexes for O(1) lookups
    this.trackersBySlug.set(unifiedMarket.slug, unifiedMarket.conditionId);

    // Add to symbol index
    let symbolSet = this.trackersBySymbol.get(symbol);
    if (!symbolSet) {
      symbolSet = new Set();
      this.trackersBySymbol.set(symbol, symbolSet);
    }
    symbolSet.add(unifiedMarket.conditionId);

    this.logger.info(LogEvents.MARKET_ADDED, {
      marketId: unifiedMarket.conditionId,
      slug: unifiedMarket.slug,
      symbol: ASSET_TO_SYMBOL[asset],
    });

    this.emit('marketAdded', {
      conditionId: unifiedMarket.conditionId,
      slug: unifiedMarket.slug,
      asset,
      endTime: tracker.endTime,
    });
  }

  // ============================================================================
  // Price Updates
  // ============================================================================

  /**
   * Subscribe to crypto price updates via WebSocket
   */
  private subscribeToPriceUpdates(): void {
    // Ensure realtime service is connected
    if (!this.realtimeService.isConnected()) {
      this.realtimeService.connect();
    }

    // Subscribe to Chainlink prices (used by Polymarket for crypto markets)
    // The symbols use format like "BTC/USD", "ETH/USD"
    const chainlinkSymbols = this.config.symbols.map(s => {
      const asset = SYMBOL_TO_ASSET[s];
      return `${asset}/USD`;
    });

    this.priceSubscription = this.realtimeService.subscribeCryptoChainlinkPrices(
      chainlinkSymbols,
      {
        onPrice: (price: CryptoPrice) => this.onPriceUpdate(price),
        onError: (error: Error) => this.handleError(error),
      }
    );

    this.logger.info(LogEvents.PRICE_SUBSCRIPTION_ACTIVE, {
      message: `Subscribed to crypto prices: ${chainlinkSymbols.join(', ')}`,
    });
  }

  /**
   * Handle price update from WebSocket
   *
   * Routes the price to all relevant feature engines and evaluates signals.
   * Uses secondary index for O(1) lookup instead of iterating all trackers.
   * Validates price data to prevent manipulation attacks.
   */
  private onPriceUpdate(priceUpdate: CryptoPrice): void {
    // Convert symbol format (e.g., "BTC/USD" -> "BTC") with validation
    const asset = this.parseAssetFromPriceSymbol(priceUpdate.symbol);
    if (!asset) {
      return; // Unknown or invalid asset
    }

    const symbol = ASSET_TO_SYMBOL[asset];
    if (!symbol) {
      return; // Unknown symbol mapping
    }

    const price = priceUpdate.price;
    const timestamp = priceUpdate.timestamp;

    // Validate price data to prevent manipulation
    if (!this.isValidPrice(price, asset)) {
      return; // Invalid price rejected
    }

    // Use secondary index for O(1) lookup of trackers by symbol
    const trackerIds = this.trackersBySymbol.get(symbol);
    if (!trackerIds || trackerIds.size === 0) {
      return; // No trackers for this symbol
    }

    // Route price to all trackers for this symbol
    for (const conditionId of trackerIds) {
      const tracker = this.trackers.get(conditionId);
      if (!tracker) {
        continue; // Tracker was removed
      }

      // Ingest price and get features if at minute boundary
      const features = tracker.featureEngine.ingestPrice(price, timestamp);

      if (features) {
        // Record minute price at each minute boundary
        this.recordMinutePrice(tracker, features.stateMinute, price, timestamp);

        // We're at a minute boundary - evaluate for signal
        this.evaluateSignal(tracker, features);
      }
    }
  }

  /**
   * Record a minute price snapshot for a tracker
   *
   * Stores the price in the tracker's minutePrices Map and persists
   * to database if a trade has been recorded for this market.
   * Uses O(1) Map lookup for duplicate detection.
   */
  private recordMinutePrice(
    tracker: MarketTracker,
    minuteOffset: number,
    price: number,
    timestamp: number
  ): void {
    // Validate minuteOffset is within valid range (0-14 for 15-minute window)
    if (minuteOffset < 0 || minuteOffset > MAX_MINUTE_OFFSET) {
      this.logger.error(LogEvents.PERSISTENCE_ERROR, {
        marketId: tracker.conditionId,
        minuteOffset,
        message: `Invalid minuteOffset ${minuteOffset}, must be 0-14`,
      });
      return;
    }

    // O(1) check if we already have a price for this minute offset (avoid duplicates)
    if (tracker.minutePrices.has(minuteOffset)) {
      return; // Already recorded this minute
    }

    // Add to tracker's minute prices Map
    tracker.minutePrices.set(minuteOffset, {
      minuteOffset,
      timestamp,
      price,
    });

    // Capture values before async boundary to avoid non-null assertions
    const repo = this.tradeRepository;
    const tradeId = tracker.tradeId;
    const marketId = tracker.conditionId;

    // If we have a trade ID and repository, persist to database
    if (tradeId !== undefined && repo) {
      // Use setImmediate to avoid blocking the trading hot path
      // Use promise chaining instead of async wrapper to avoid unhandled rejections
      setImmediate(() => {
        repo.recordMinutePrice(tradeId, minuteOffset, price, timestamp)
          .catch(error => {
            // Log error but don't crash - minute price persistence is non-critical
            this.logger.error(LogEvents.PERSISTENCE_ERROR, {
              marketId,
              minuteOffset,
              error: error instanceof Error ? error.message : String(error),
              message: 'Failed to persist minute price',
            });
          });
      });
    }
  }

  /**
   * Validate that a price is reasonable (not negative, not extreme outlier)
   */
  private isValidPrice(price: number, asset: CryptoAsset): boolean {
    if (price <= 0 || !Number.isFinite(price)) {
      return false;
    }
    const maxPrice = MAX_REASONABLE_PRICE[asset];
    if (price > maxPrice) {
      return false;
    }
    return true;
  }

  /**
   * Refresh tracker prices from market service
   *
   * Fetches current market prices to avoid stale entry price decisions.
   * Returns null if refresh fails (non-critical - will use cached prices).
   */
  private async refreshTrackerPrices(
    tracker: MarketTracker
  ): Promise<{ yes: number; no: number } | null> {
    try {
      const market = await this.marketService.getMarket(tracker.conditionId);
      if (!market?.tokens || market.tokens.length < 2) {
        return null;
      }

      const tokens = this.findTokensByOutcome(market.tokens);
      if (!tokens.yes || !tokens.no) {
        return null;
      }

      // Update tracker cache
      tracker.prices.yes = tokens.yes.price;
      tracker.prices.no = tokens.no.price;

      return { yes: tokens.yes.price, no: tokens.no.price };
    } catch {
      // Non-critical failure - use cached prices
      return null;
    }
  }

  /**
   * Parse and validate CryptoAsset from price symbol (e.g., "BTC/USD" -> "BTC")
   */
  private parseAssetFromPriceSymbol(symbol: string): CryptoAsset | null {
    const slashIndex = symbol.indexOf('/');
    const prefix = slashIndex > 0 ? symbol.substring(0, slashIndex) : symbol;

    // Use type guard for validation
    if (isCryptoAsset(prefix)) {
      return prefix;
    }
    return null;
  }

  // ============================================================================
  // Signal Generation & Execution
  // ============================================================================

  /**
   * Evaluate whether to generate a signal based on features
   *
   * Checks:
   * 1. State minute is in allowed range (default: [0, 1, 2])
   * 2. Model confidence meets threshold (>= 0.70 for YES, <= 0.30 for NO)
   * 3. Entry price is acceptable (<= 0.70)
   * 4. Haven't already traded this market
   */
  private evaluateSignal(tracker: MarketTracker, features: FeatureVector): void {
    // Skip if already traded
    if (tracker.traded) {
      return;
    }

    // Check state minute
    if (!this.config.stateMinutes.includes(features.stateMinute)) {
      return;
    }

    // Get model for this symbol
    const model = this.models.get(tracker.symbol);
    if (!model) {
      return; // No model found for symbol - skip evaluation
    }

    // Run prediction
    const featureMap = Crypto15FeatureEngine.toFeatureMap(features);
    const prediction = model.predict(featureMap);

    // Determine signal direction and check thresholds
    let side: 'YES' | 'NO' | null = null;
    let entryPrice = 0;

    if (prediction.probability >= this.config.yesThreshold) {
      side = 'YES';
      entryPrice = tracker.prices.yes;
    } else if (prediction.probability <= this.config.noThreshold) {
      side = 'NO';
      entryPrice = tracker.prices.no;
    }

    if (!side) {
      // No signal - probability in uncertain range
      return;
    }

    // Check entry price cap
    if (entryPrice > this.config.entryPriceCap) {
      this.logger.warn(LogEvents.SIGNAL_REJECTED, {
        marketId: tracker.conditionId,
        slug: tracker.slug,
        symbol: tracker.symbol,
        side,
        entryPrice,
        confidence: prediction.probability,
        message: `Entry price ${entryPrice.toFixed(3)} exceeds cap ${this.config.entryPriceCap}`,
      });
      return;
    }

    // Generate signal
    const signal: Signal = {
      conditionId: tracker.conditionId,
      slug: tracker.slug,
      asset: tracker.asset,
      side,
      probability: prediction.probability,
      linearCombination: prediction.linearCombination,
      imputedCount: prediction.imputedCount,
      entryPrice,
      stateMinute: features.stateMinute,
      timestamp: Date.now(),
      features,
    };

    // Guard to avoid log context object allocation when logging is disabled
    if (this.logger.isEnabled()) {
      this.logger.info(LogEvents.SIGNAL_GENERATED, {
        marketId: tracker.conditionId,
        slug: tracker.slug,
        symbol: tracker.symbol,
        stateMinute: features.stateMinute,
        side,
        confidence: prediction.probability,
        entryPrice,
        imputedFeatures: prediction.imputedCount,
        linearCombination: prediction.linearCombination,
      });
    }

    // Mark as traded BEFORE async execution to prevent race conditions
    // This ensures rapid price updates don't trigger duplicate trades
    tracker.traded = true;

    this.emit('signal', signal);

    // Execute the signal (fire-and-forget with error handling)
    this.executeSignal(tracker, signal).catch(e => this.handleError(e));
  }

  /**
   * Execute a trading signal by placing a market order
   *
   * Refreshes market prices before execution to ensure entry price is current.
   */
  private async executeSignal(tracker: MarketTracker, signal: Signal): Promise<void> {
    // Refresh market prices before execution to avoid stale entry prices
    const freshPrices = await this.refreshTrackerPrices(tracker);
    if (freshPrices) {
      // Re-validate entry price with fresh data
      const freshEntryPrice = signal.side === 'YES' ? freshPrices.yes : freshPrices.no;
      if (freshEntryPrice > this.config.entryPriceCap) {
        this.logger.warn(LogEvents.SIGNAL_REJECTED, {
          marketId: tracker.conditionId,
          slug: tracker.slug,
          symbol: tracker.symbol,
          side: signal.side,
          entryPrice: freshEntryPrice,
          message: `Fresh entry price ${freshEntryPrice.toFixed(3)} exceeds cap, skipping execution`,
        });
        // Reset traded flag since we didn't actually trade
        tracker.traded = false;
        return;
      }
      // Update signal with fresh price for accurate logging
      signal.entryPrice = freshEntryPrice;
    }

    if (this.config.dryRun) {
      // Record paper position for tracking (pass tracker for persistence)
      this.recordPaperPosition(signal, tracker);

      const executionResult: ExecutionResult = {
        signal,
        orderResult: {
          success: true,
          orderId: 'dry-run-' + Date.now(),
        },
        timestamp: Date.now(),
      };

      this.emit('execution', executionResult);
      return;
    }

    try {
      // Determine which token to buy
      const tokenId = signal.side === 'YES' ? tracker.tokenIds.yes : tracker.tokenIds.no;

      // Create market order
      const orderResult = await this.tradingService.createMarketOrder({
        tokenId,
        side: 'BUY',
        amount: this.config.positionSizeUsd,
        orderType: 'FOK', // Fill or Kill
      });

      const executionResult: ExecutionResult = {
        signal,
        orderResult,
        timestamp: Date.now(),
      };

      if (orderResult.success) {
        this.logger.info(LogEvents.EXECUTION_SUCCESS, {
          marketId: signal.conditionId,
          slug: signal.slug,
          symbol: tracker.symbol,
          side: signal.side,
          entryPrice: signal.entryPrice,
          size: this.config.positionSizeUsd,
          orderId: orderResult.orderId,
          success: true,
        });
      } else {
        this.logger.error(LogEvents.EXECUTION_FAILED, {
          marketId: signal.conditionId,
          slug: signal.slug,
          symbol: tracker.symbol,
          side: signal.side,
          error: orderResult.errorMsg,
          success: false,
        });
      }

      this.emit('execution', executionResult);
    } catch (error) {
      this.handleError(error);

      // Reset traded flag on transient errors to allow retry on next price tick
      if (isTransientError(error)) {
        tracker.traded = false;
        this.logger.warn(LogEvents.EXECUTION_FAILED, {
          marketId: tracker.conditionId,
          slug: tracker.slug,
          symbol: tracker.symbol,
          error: StrategyLogger.sanitizeErrorMessage(error),
          errorCode: 'transient',
          message: 'Transient error, will retry',
        });
      }

      const executionResult: ExecutionResult = {
        signal,
        orderResult: {
          success: false,
          errorMsg: error instanceof Error ? error.message : String(error),
        },
        timestamp: Date.now(),
      };

      this.emit('execution', executionResult);
    }
  }

  // ============================================================================
  // Cleanup
  // ============================================================================

  /**
   * Remove trackers for expired markets
   *
   * Runs every 30 seconds.
   * Maintains secondary indexes when removing trackers.
   */
  private cleanupStaleTrackers(): void {
    const now = Date.now();
    const expired: Array<[string, MarketTracker]> = [];

    for (const [conditionId, tracker] of this.trackers) {
      // Remove if market has ended
      if (tracker.endTime < now) {
        expired.push([conditionId, tracker]);
      }
    }

    for (const [conditionId, tracker] of expired) {
      // Remove from primary map
      this.trackers.delete(conditionId);

      // Remove from secondary indexes
      this.trackersBySlug.delete(tracker.slug);

      const symbolSet = this.trackersBySymbol.get(tracker.symbol);
      if (symbolSet) {
        symbolSet.delete(conditionId);
        // Clean up empty sets
        if (symbolSet.size === 0) {
          this.trackersBySymbol.delete(tracker.symbol);
        }
      }

      this.logger.info(LogEvents.MARKET_REMOVED, {
        marketId: conditionId,
        slug: tracker.slug,
        symbol: tracker.symbol,
      });

      this.emit('marketRemoved', {
        conditionId,
        slug: tracker.slug,
        asset: tracker.asset,
        traded: tracker.traded,
      });
    }

    // Log cleanup summary if any trackers were removed
    if (expired.length > 0) {
      this.logger.info(LogEvents.TRACKERS_CLEANED, {
        removedCount: expired.length,
        remainingCount: this.trackers.size,
        message: `Cleaned up ${expired.length} expired trackers`,
      });
    }
  }

  // ============================================================================
  // Helper Methods
  // ============================================================================

  /**
   * Check if a slug matches the 15m market pattern
   */
  private is15mMarket(slug: string): boolean {
    // Pattern: {coin}-updown-15m-{timestamp}
    return /^(btc|eth|sol|xrp)-updown-15m-\d+$/.test(slug);
  }

  /**
   * Infer crypto asset from market slug
   */
  private inferAssetFromSlug(slug: string): CryptoAsset | null {
    // Extract coin from slug (e.g., "btc-updown-15m-1767456000" -> "btc")
    const match = slug.match(/^(btc|eth|sol|xrp)-updown-/);
    if (match) {
      return COIN_TO_ASSET[match[1]] ?? null;
    }
    return null;
  }

  /**
   * Check if we already have a tracker for a given slug
   * Uses secondary index for O(1) lookup
   */
  private hasTrackerForSlug(slug: string): boolean {
    return this.trackersBySlug.has(slug);
  }

  /**
   * Find YES and NO tokens from a token array
   *
   * Extracts tokens by outcome name for robustness against API changes.
   * Crypto markets use 'Up'/'Down', but we also check 'Yes'/'No' for compatibility.
   * Returns undefined for tokens that are not found.
   */
  private findTokensByOutcome(
    tokens: Array<{ outcome?: string; tokenId?: string; price?: number }>
  ): TokenLookupResult {
    const yesToken = tokens.find(t => t.outcome === 'Up' || t.outcome === 'Yes');
    const noToken = tokens.find(t => t.outcome === 'Down' || t.outcome === 'No');

    return {
      yes: yesToken?.tokenId ? { tokenId: yesToken.tokenId, price: yesToken.price ?? 0.5 } : undefined,
      no: noToken?.tokenId ? { tokenId: noToken.tokenId, price: noToken.price ?? 0.5 } : undefined,
    };
  }

  /**
   * Handle an error by emitting it and logging with structured format
   */
  private handleError(error: unknown): void {
    const errorObj = error instanceof Error ? error : new Error(String(error));
    this.logger.error(LogEvents.ERROR, {
      error: StrategyLogger.sanitizeErrorMessage(errorObj),
      errorCode: this.classifyError(error),
    });
    this.emit('error', errorObj);
  }

  /**
   * Classify an error into a category for filtering
   */
  private classifyError(error: unknown): ErrorCategory {
    if (!(error instanceof Error)) return 'unknown';
    const msg = error.message.toLowerCase();
    if (msg.includes('websocket')) return 'websocket';
    if (msg.includes('timeout') || msg.includes('econnreset')) return 'network';
    if (msg.includes('rate limit') || msg.includes('429')) return 'rate_limit';
    if (msg.includes('model') || msg.includes('inference')) return 'model';
    if (msg.includes('feature')) return 'feature';
    return 'general';
  }

  // ============================================================================
  // Paper Trading (Dry-Run Mode)
  // ============================================================================

  /** Maximum number of paper positions to prevent unbounded memory growth */
  private static readonly MAX_PAPER_POSITIONS = 1000;

  /**
   * Fields to check for market outcome, in priority order.
   * 'winner' is the standard field for resolved markets,
   * 'outcome' and 'winning_outcome' are fallbacks for alternative event formats.
   */
  private static readonly OUTCOME_FIELD_NAMES = ['winner', 'outcome', 'winning_outcome'] as const;

  /**
   * Format P&L value as a display string with +/- prefix
   */
  private formatPnL(pnl: number): string {
    return pnl >= 0 ? `+$${pnl.toFixed(2)}` : `-$${Math.abs(pnl).toFixed(2)}`;
  }

  /**
   * Determine if a position wins based on side and outcome
   */
  private isWinningPosition(side: 'YES' | 'NO', outcome: 'UP' | 'DOWN'): boolean {
    return (side === 'YES' && outcome === 'UP') ||
           (side === 'NO' && outcome === 'DOWN');
  }

  /**
   * Convert a Signal to a TradeRecord for persistence
   *
   * Creates a complete TradeRecord from a generated signal with all
   * required fields for database storage.
   */
  private signalToTradeRecord(signal: Signal, tracker: MarketTracker): TradeRecord {
    const now = new Date();
    // Get window state from feature engine to access open price
    const engineState = tracker.featureEngine.getState();
    const windowOpenPrice = engineState.windowState?.openPrice;

    return {
      conditionId: signal.conditionId,
      slug: signal.slug,
      symbol: signal.asset,
      side: signal.side,
      entryPrice: signal.entryPrice,
      positionSize: this.config.positionSizeUsd,
      signalTimestamp: signal.timestamp,
      probability: signal.probability,
      linearCombination: signal.linearCombination,
      imputedCount: signal.imputedCount,
      features: signal.features,
      stateMinute: signal.stateMinute,
      hourOfDay: now.getUTCHours(),
      dayOfWeek: now.getUTCDay(),
      volatility5m: signal.features.volatility5m,
      windowOpenPrice,
      entryBidPrice: tracker.prices.no, // NO price is bid-like
      entryAskPrice: tracker.prices.yes, // YES price is ask-like
    };
  }

  /**
   * Persist a trade to the repository asynchronously
   *
   * Uses setImmediate to avoid blocking the trading hot path.
   * Errors are logged but don't crash the service.
   * After persistence, stores tradeId on tracker and persists any
   * already-collected minute prices.
   */
  private persistTrade(signal: Signal, tracker: MarketTracker): void {
    const repo = this.tradeRepository;
    if (!repo) {
      return; // Persistence not enabled
    }

    const tradeRecord = this.signalToTradeRecord(signal, tracker);
    const conditionId = signal.conditionId;

    // Use setImmediate to avoid blocking the trading hot path
    // Use promise chaining instead of async wrapper to avoid unhandled rejections
    setImmediate(() => {
      repo.recordTrade(tradeRecord)
        .then(tradeId => {
          this.persistedTrades.add(conditionId);

          // Store tradeId on tracker for future minute price persistence
          tracker.tradeId = tradeId;

          this.logger.info(LogEvents.TRADE_PERSISTED, {
            marketId: conditionId,
            slug: signal.slug,
            tradeId,
            message: `Trade persisted with ID ${tradeId}`,
          });

          // Persist any minute prices that were collected before trade was recorded
          return this.persistExistingMinutePrices(tracker, tradeId);
        })
        .catch(error => {
          // Log error but don't crash - persistence is non-critical
          this.logger.error(LogEvents.PERSISTENCE_ERROR, {
            marketId: conditionId,
            slug: signal.slug,
            error: error instanceof Error ? error.message : String(error),
            message: 'Failed to persist trade',
          });
        });
    });
  }

  /**
   * Persist any minute prices that were collected before the trade was persisted
   *
   * This handles the case where minute prices are recorded at minute boundaries
   * before the trade signal is generated (which happens at state minutes 0, 1, 2).
   * Uses batch insert for efficiency (single DB operation instead of N).
   */
  private async persistExistingMinutePrices(
    tracker: MarketTracker,
    tradeId: number
  ): Promise<void> {
    const repo = this.tradeRepository;
    if (!repo || tracker.minutePrices.size === 0) {
      return;
    }

    const marketId = tracker.conditionId;
    const minutePricesArray = Array.from(tracker.minutePrices.values());

    try {
      // Use batch insert for efficiency (single DB transaction)
      await repo.recordMinutePrices(tradeId, minutePricesArray);

      this.logger.info(LogEvents.TRADE_PERSISTED, {
        marketId,
        tradeId,
        minutePriceCount: minutePricesArray.length,
        message: `Persisted ${minutePricesArray.length} existing minute prices`,
      });
    } catch (error) {
      // Log error but don't crash - minute price persistence is non-critical
      this.logger.error(LogEvents.PERSISTENCE_ERROR, {
        marketId,
        tradeId,
        error: error instanceof Error ? error.message : String(error),
        message: 'Failed to persist existing minute prices',
      });
    }
  }

  /**
   * Record a paper position for dry-run mode
   *
   * Stores the position without executing a real trade.
   * Emits 'paperPosition' event for tracking.
   * If persistence is enabled, also persists to database.
   */
  private recordPaperPosition(signal: Signal, tracker: MarketTracker): void {
    // Guard: prevent overwriting existing position
    if (this.paperPositions.has(signal.conditionId)) {
      this.logger.warn(LogEvents.PAPER_POSITION, {
        marketId: signal.conditionId,
        slug: signal.slug,
        message: 'Paper position already exists, skipping',
        dryRun: true,
      });
      return;
    }

    // Guard: prevent unbounded memory growth
    if (this.paperPositions.size >= Crypto15MLStrategyService.MAX_PAPER_POSITIONS) {
      const oldestKey = this.paperPositions.keys().next().value;
      if (oldestKey) {
        const evictedPosition = this.paperPositions.get(oldestKey);
        this.paperPositions.delete(oldestKey);
        this.logger.warn(LogEvents.PAPER_POSITION_EVICTED, {
          marketId: oldestKey,
          slug: evictedPosition?.slug,
          message: `Evicted oldest paper position due to limit of ${Crypto15MLStrategyService.MAX_PAPER_POSITIONS}`,
          dryRun: true,
        });
      }
    }

    const position: PaperPosition = {
      marketId: signal.conditionId,
      slug: signal.slug,
      symbol: signal.asset,
      side: signal.side,
      entryPrice: signal.entryPrice,
      size: this.config.positionSizeUsd,
      confidence: signal.probability,
      timestamp: new Date(),
    };

    this.paperPositions.set(signal.conditionId, position);

    this.logger.info(LogEvents.PAPER_POSITION, {
      marketId: signal.conditionId,
      slug: signal.slug,
      symbol: ASSET_TO_SYMBOL[signal.asset],
      side: signal.side,
      entryPrice: signal.entryPrice,
      confidence: signal.probability,
      size: this.config.positionSizeUsd,
      dryRun: true,
    });

    this.emit('paperPosition', position);

    // Persist trade to database if repository is available
    this.persistTrade(signal, tracker);
  }

  /**
   * Calculate paper P&L for a resolved market
   *
   * P&L calculation:
   * - If YES position and outcome = UP: pnl = (1.0 - entryPrice) * size
   * - If YES position and outcome = DOWN: pnl = -entryPrice * size
   * - If NO position and outcome = DOWN: pnl = (1.0 - entryPrice) * size
   * - If NO position and outcome = UP: pnl = -entryPrice * size
   *
   * Returns object with both pnl and won flag to avoid duplicate calculation.
   */
  private calculatePaperPnL(
    position: PaperPosition,
    outcome: 'UP' | 'DOWN'
  ): { pnl: number; won: boolean } {
    const won = this.isWinningPosition(position.side, outcome);

    if (won) {
      // Win: profit = (1 - entryPrice) * size
      return { pnl: (1.0 - position.entryPrice) * position.size, won };
    } else {
      // Loss: loss = -entryPrice * size
      return { pnl: -position.entryPrice * position.size, won };
    }
  }

  /**
   * Calculate Maximum Favorable and Adverse Excursions for a position
   *
   * MFE (Maximum Favorable Excursion): Best price move in trade's favor
   * MAE (Maximum Adverse Excursion): Worst price move against trade
   *
   * For YES positions: run-up is favorable, run-down is adverse
   * For NO positions: run-down is favorable, run-up is adverse
   */
  private calculateExcursions(
    tracker: MarketTracker,
    side: 'YES' | 'NO'
  ): { mfe: number; mae: number } {
    const windowState = tracker.featureEngine.getState().windowState;
    if (!windowState) {
      return { mfe: 0, mae: 0 };
    }

    const runUp = Math.abs(windowState.maxRunUp);
    const runDown = Math.abs(windowState.maxRunDown);

    if (side === 'YES') {
      return { mfe: runUp, mae: runDown };
    } else {
      return { mfe: runDown, mae: runUp };
    }
  }

  /**
   * Check if a threshold minute value represents a valid "hit" event
   *
   * The feature engine uses NaN to represent "threshold was never hit" during
   * the window. This helper provides semantic clarity for that check.
   *
   * @returns true if the minute value is a valid number (threshold was hit)
   */
  private isValidThresholdMinute(minute: number): boolean {
    return !Number.isNaN(minute) && Number.isFinite(minute);
  }

  /**
   * Calculate timing metrics from feature engine's window state
   *
   * Returns the minutes until each threshold was first hit.
   * Returns undefined for thresholds that were never hit.
   */
  private calculateTimingMetrics(
    tracker: MarketTracker
  ): { timeToUpThreshold?: number; timeToDownThreshold?: number } {
    const windowState = tracker.featureEngine.getState().windowState;
    if (!windowState) {
      return {};
    }

    return {
      timeToUpThreshold: this.isValidThresholdMinute(windowState.firstUpHitMinute)
        ? windowState.firstUpHitMinute
        : undefined,
      timeToDownThreshold: this.isValidThresholdMinute(windowState.firstDownHitMinute)
        ? windowState.firstDownHitMinute
        : undefined,
    };
  }

  /**
   * Get window close price from minute prices
   *
   * Returns the price at minute 14 (last minute of window) if available.
   * Returns undefined if minute 14 price is not yet recorded.
   * Uses O(1) Map lookup.
   */
  private getWindowClosePrice(tracker: MarketTracker): number | undefined {
    // Window close is the last minute (0-indexed, 15 minute window)
    // O(1) lookup using Map.get instead of O(n) array.find
    return tracker.minutePrices.get(MAX_MINUTE_OFFSET)?.price;
  }

  /**
   * Persist outcome update to the database asynchronously
   *
   * Uses setImmediate to avoid blocking. Errors are logged but don't crash.
   * Always cleans up persistedTrades entry regardless of success/failure.
   */
  private persistOutcome(
    conditionId: string,
    outcome: TradeOutcome
  ): void {
    const repo = this.tradeRepository;
    if (!repo) {
      return; // Persistence not enabled
    }

    // Use setImmediate to avoid blocking
    // Use promise chaining instead of async wrapper to avoid unhandled rejections
    setImmediate(() => {
      repo.updateOutcome(conditionId, outcome)
        .then(() => {
          this.logger.info(LogEvents.OUTCOME_PERSISTED, {
            marketId: conditionId,
            outcome: outcome.outcome,
            isWin: outcome.isWin,
            pnl: outcome.pnl,
            message: `Outcome persisted: ${outcome.outcome} (${outcome.isWin ? 'WIN' : 'LOSS'})`,
          });
        })
        .catch(error => {
          // Log error but don't crash - persistence is non-critical
          this.logger.error(LogEvents.PERSISTENCE_ERROR, {
            marketId: conditionId,
            error: error instanceof Error ? error.message : String(error),
            message: 'Failed to persist outcome',
          });
        })
        .finally(() => {
          // Always clean up tracking entry to prevent memory leaks
          this.persistedTrades.delete(conditionId);
        });
    });
  }

  /**
   * Handle market resolution event for paper trading
   *
   * Called when a market resolves. Looks up any paper position
   * for this market, calculates P&L, and emits settlement event.
   * If persistence is enabled, updates the outcome in the database.
   */
  private handleMarketResolution(conditionId: string, outcome: 'UP' | 'DOWN'): void {
    const position = this.paperPositions.get(conditionId);
    if (!position) {
      return; // No paper position for this market
    }

    const { pnl, won } = this.calculatePaperPnL(position, outcome);

    // Update cumulative P&L
    this.paperPnL += pnl;

    const settlement: PaperSettlement = {
      position,
      outcome,
      won,
      pnl,
      timestamp: new Date(),
    };

    this.logger.info(LogEvents.PAPER_SETTLEMENT, {
      marketId: conditionId,
      slug: position.slug,
      symbol: ASSET_TO_SYMBOL[position.symbol],
      side: position.side,
      entryPrice: position.entryPrice,
      pnl,
      success: won,
      dryRun: true,
      message: `Settlement: ${won ? 'WIN' : 'LOSS'} | pnl: ${this.formatPnL(pnl)}`,
    });

    this.emit('paperSettlement', settlement);

    // Persist outcome to database if we have a tracked trade
    if (this.persistedTrades.has(conditionId)) {
      // Get tracker for metrics calculation (may be null if already cleaned up)
      const tracker = this.trackers.get(conditionId);

      // Calculate metrics from tracker (or use defaults if tracker unavailable)
      const excursions = tracker
        ? this.calculateExcursions(tracker, position.side)
        : { mfe: 0, mae: 0 };

      const timingMetrics = tracker
        ? this.calculateTimingMetrics(tracker)
        : {};

      const windowClosePrice = tracker
        ? this.getWindowClosePrice(tracker)
        : undefined;

      const tradeOutcome: TradeOutcome = {
        outcome,
        isWin: won,
        pnl,
        resolutionTimestamp: Date.now(),
        windowClosePrice,
        timeToUpThreshold: timingMetrics.timeToUpThreshold,
        timeToDownThreshold: timingMetrics.timeToDownThreshold,
        maxFavorableExcursion: excursions.mfe,
        maxAdverseExcursion: excursions.mae,
      };

      this.persistOutcome(conditionId, tradeOutcome);
    }

    // Remove settled position
    this.paperPositions.delete(conditionId);
  }

  /**
   * Subscribe to market resolution events for paper trading
   *
   * Uses realtimeService to get market lifecycle events.
   * When a market resolves, triggers paper P&L calculation.
   * Only call this method when dryRun mode is enabled.
   */
  private subscribeToMarketResolutions(): void {
    this.marketEventSubscription = this.realtimeService.subscribeMarketEvents({
      onMarketEvent: (event) => {
        try {
          if (event.type !== 'resolved') {
            return;
          }

          // Check if we have a paper position for this market
          if (!this.paperPositions.has(event.conditionId)) {
            return;
          }

          // Determine outcome from event data
          // The resolved market data should indicate which outcome won
          const outcome = this.parseMarketOutcome(event);
          if (outcome) {
            this.handleMarketResolution(event.conditionId, outcome);
          }
        } catch (error) {
          this.emit('error', error instanceof Error ? error : new Error(String(error)));
        }
      },
    });

  }

  /**
   * Parse outcome string to UP/DOWN using strict matching
   *
   * Uses exact match after normalization to avoid false positives
   * from strings like "notupbutdown".
   */
  private parseOutcomeString(value: unknown): 'UP' | 'DOWN' | null {
    if (value == null) return null;

    const normalized = String(value).toLowerCase().trim();

    // Strict equality matching for known outcome values
    if (normalized === 'up' || normalized === 'yes') {
      return 'UP';
    }
    if (normalized === 'down' || normalized === 'no') {
      return 'DOWN';
    }

    return null;
  }

  /**
   * Parse market outcome from resolution event
   *
   * Tries to determine if the market resolved UP or DOWN
   * from the event data. Uses strict matching to avoid
   * false positives from malformed data.
   */
  private parseMarketOutcome(event: { data?: Record<string, unknown> }): 'UP' | 'DOWN' | null {
    // Guard against malformed events
    if (!event?.data || typeof event.data !== 'object') {
      return null; // Malformed event data
    }

    const data = event.data;

    // Check known fields in priority order
    for (const field of Crypto15MLStrategyService.OUTCOME_FIELD_NAMES) {
      const result = this.parseOutcomeString(data[field]);
      if (result) {
        return result;
      }
    }

    // Could not determine outcome - skip this resolution
    return null;
  }

  /**
   * Get current paper trading statistics
   *
   * Returns a snapshot of the current paper trading state.
   * The positions array is a copy - modifications do not affect internal state.
   *
   * @returns Current paper trading statistics snapshot
   */
  getPaperTradingStats(): PaperTradingStats {
    return {
      positionCount: this.paperPositions.size,
      cumulativePnL: this.paperPnL,
      positions: Array.from(this.paperPositions.values()),
    };
  }
}
