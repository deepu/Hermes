/**
 * Crypto15MLStrategyService
 *
 * Main orchestration service for the 15-minute binary crypto market strategy.
 * Discovers markets, ingests prices, computes features, generates signals,
 * and executes trades.
 *
 * Key responsibilities:
 * - Load trained models and imputations on startup
 * - Subscribe to real-time crypto price feeds (BTC, ETH, SOL, XRP)
 * - Implement hybrid market discovery:
 *   - Predictive scanning: Pre-create trackers for upcoming markets (every 10 min)
 *   - Reactive scanning: Discover active markets (every 1 min)
 * - Maintain Crypto15FeatureEngine instances per market
 * - Ingest prices and compute features at minute boundaries
 * - Generate signals when conditions are met
 * - Execute market orders via TradingService
 * - Emit events: 'signal', 'execution', 'error', 'marketAdded', 'marketRemoved'
 * - Cleanup stale trackers (every 30 seconds)
 *
 * Part of #6
 */

import { EventEmitter } from 'events';
import {
  Crypto15FeatureEngine,
  type CryptoAsset,
  type FeatureVector,
} from '../strategies/crypto15-feature-engine.js';
import { Crypto15LRModel } from '../strategies/crypto15-lr-model.js';
import { loadModelsWithImputations } from '../strategies/model-loader.js';
import type { MarketService } from './market-service.js';
import type { TradingService, OrderResult } from './trading-service.js';
import type { RealtimeServiceV2, CryptoPrice, Subscription } from './realtime-service-v2.js';
import type { GammaMarket } from '../clients/gamma-api.js';
import type { UnifiedMarket } from '../core/types.js';

// ============================================================================
// Types
// ============================================================================

/**
 * Configuration for Crypto15MLStrategyService
 */
export interface Crypto15MLConfig {
  /** Enable or disable the strategy */
  enabled: boolean;
  /** Path to the model JSON file */
  modelPath: string;
  /** Path to the imputation JSON file */
  imputationPath: string;
  /** State minutes when signals can be generated (default: [0, 1, 2]) */
  stateMinutes: number[];
  /** Horizon in minutes for the strategy (default: 15) */
  horizonMinutes: number;
  /** Probability threshold for YES signal (default: 0.70) */
  yesThreshold: number;
  /** Probability threshold for NO signal (default: 0.30) */
  noThreshold: number;
  /** Maximum entry price (default: 0.70) */
  entryPriceCap: number;
  /** Position size in USD (default: 100.0) */
  positionSizeUsd: number;
  /** Symbols to track (e.g., ['BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'XRPUSDT']) */
  symbols: string[];
  /** Threshold in basis points per symbol for up/down detection */
  thresholdBps: Record<string, number>;
  /** Enable debug logging */
  debug?: boolean;
  /** Dry run mode - generate signals but don't execute trades */
  dryRun?: boolean;
}

/**
 * Signal generated by the strategy
 */
export interface Signal {
  /** Market condition ID */
  conditionId: string;
  /** Market slug */
  slug: string;
  /** Crypto asset symbol (BTC, ETH, SOL, XRP) */
  asset: CryptoAsset;
  /** Signal direction */
  side: 'YES' | 'NO';
  /** Model probability (0-1) */
  probability: number;
  /** Linear combination (z-score before sigmoid) */
  linearCombination: number;
  /** Number of features that were imputed */
  imputedCount: number;
  /** Current market price for the signal side */
  entryPrice: number;
  /** State minute when signal was generated (0-14) */
  stateMinute: number;
  /** Timestamp when signal was generated */
  timestamp: number;
  /** Feature vector used for prediction */
  features: FeatureVector;
}

/**
 * Execution result for a signal
 */
export interface ExecutionResult {
  /** The signal that was executed */
  signal: Signal;
  /** Order result from TradingService */
  orderResult: OrderResult;
  /** Timestamp of execution */
  timestamp: number;
}

/**
 * Market tracker maintaining state for each active market
 */
interface MarketTracker {
  /** Market condition ID */
  conditionId: string;
  /** Market slug */
  slug: string;
  /** Crypto asset (BTC, ETH, SOL, XRP) */
  asset: CryptoAsset;
  /** Binance symbol (e.g., BTCUSDT) */
  symbol: string;
  /** Feature engine instance */
  featureEngine: Crypto15FeatureEngine;
  /** Market end timestamp (ms) */
  endTime: number;
  /** Token IDs for YES and NO outcomes */
  tokenIds: { yes: string; no: string };
  /** Current prices */
  prices: { yes: number; no: number };
  /** Whether we've already traded this market */
  traded: boolean;
  /** When this tracker was created */
  createdAt: number;
}

// ============================================================================
// Constants
// ============================================================================

/** Window duration in minutes */
const WINDOW_MINUTES = 15;

/** Window duration in milliseconds */
const WINDOW_MS = WINDOW_MINUTES * 60 * 1000;

/** Predictive scan interval (10 minutes) */
const PREDICTIVE_SCAN_INTERVAL_MS = 10 * 60 * 1000;

/** Reactive scan interval (1 minute) */
const REACTIVE_SCAN_INTERVAL_MS = 1 * 60 * 1000;

/** Cleanup interval (30 seconds) */
const CLEANUP_INTERVAL_MS = 30 * 1000;

/** Lookahead time for predictive scanning (30 minutes) */
const PREDICTIVE_LOOKAHEAD_MS = 30 * 60 * 1000;

/** Supported coins */
const SUPPORTED_COINS = ['btc', 'eth', 'sol', 'xrp'] as const;

/** Coin to asset mapping */
const COIN_TO_ASSET: Record<string, CryptoAsset> = {
  btc: 'BTC',
  eth: 'ETH',
  sol: 'SOL',
  xrp: 'XRP',
};

/** Symbol to asset mapping */
const SYMBOL_TO_ASSET: Record<string, CryptoAsset> = {
  BTCUSDT: 'BTC',
  ETHUSDT: 'ETH',
  SOLUSDT: 'SOL',
  XRPUSDT: 'XRP',
};

/** Asset to symbol mapping */
const ASSET_TO_SYMBOL: Record<CryptoAsset, string> = {
  BTC: 'BTCUSDT',
  ETH: 'ETHUSDT',
  SOL: 'SOLUSDT',
  XRP: 'XRPUSDT',
};

// ============================================================================
// Crypto15MLStrategyService Implementation
// ============================================================================

export class Crypto15MLStrategyService extends EventEmitter {
  private config: Crypto15MLConfig;
  private models: Map<string, Crypto15LRModel> = new Map();
  private trackers: Map<string, MarketTracker> = new Map();

  private priceSubscription: Subscription | null = null;
  private predictiveScanInterval: ReturnType<typeof setInterval> | null = null;
  private reactiveScanInterval: ReturnType<typeof setInterval> | null = null;
  private cleanupInterval: ReturnType<typeof setInterval> | null = null;

  private running = false;

  constructor(
    private marketService: MarketService,
    private tradingService: TradingService,
    private realtimeService: RealtimeServiceV2,
    config: Crypto15MLConfig
  ) {
    super();
    // Deep copy config to prevent external mutation
    this.config = {
      ...config,
      stateMinutes: [...config.stateMinutes],
      symbols: [...config.symbols],
      thresholdBps: { ...config.thresholdBps },
    };
  }

  // ============================================================================
  // Lifecycle Methods
  // ============================================================================

  /**
   * Start the strategy service
   *
   * - Loads models from JSON files
   * - Subscribes to crypto price feeds
   * - Starts predictive and reactive market scanning
   * - Starts cleanup interval
   */
  async start(): Promise<void> {
    if (this.running) {
      this.log('Already running');
      return;
    }

    if (!this.config.enabled) {
      this.log('Strategy is disabled');
      return;
    }

    this.log('Starting Crypto15MLStrategyService...');

    try {
      // Load models with imputations
      this.log(`Loading models from ${this.config.modelPath}...`);
      this.models = await loadModelsWithImputations(
        this.config.modelPath,
        this.config.imputationPath
      );
      this.log(`Loaded ${this.models.size} models: ${Array.from(this.models.keys()).join(', ')}`);

      // Subscribe to price updates
      this.subscribeToPriceUpdates();

      // Run initial scans
      await this.scanUpcomingMarkets();
      await this.scanActiveMarkets();

      // Start periodic scanning
      this.predictiveScanInterval = setInterval(
        () => this.scanUpcomingMarkets().catch(e => this.handleError(e)),
        PREDICTIVE_SCAN_INTERVAL_MS
      );

      this.reactiveScanInterval = setInterval(
        () => this.scanActiveMarkets().catch(e => this.handleError(e)),
        REACTIVE_SCAN_INTERVAL_MS
      );

      // Start cleanup interval
      this.cleanupInterval = setInterval(
        () => this.cleanupStaleTrackers(),
        CLEANUP_INTERVAL_MS
      );

      this.running = true;
      this.log('Crypto15MLStrategyService started successfully');
    } catch (error) {
      this.handleError(error);
      throw error;
    }
  }

  /**
   * Stop the strategy service
   *
   * - Unsubscribes from price feeds
   * - Clears all intervals
   * - Clears trackers
   */
  stop(): void {
    if (!this.running) {
      return;
    }

    this.log('Stopping Crypto15MLStrategyService...');

    // Unsubscribe from prices
    if (this.priceSubscription) {
      this.priceSubscription.unsubscribe();
      this.priceSubscription = null;
    }

    // Clear intervals
    if (this.predictiveScanInterval) {
      clearInterval(this.predictiveScanInterval);
      this.predictiveScanInterval = null;
    }
    if (this.reactiveScanInterval) {
      clearInterval(this.reactiveScanInterval);
      this.reactiveScanInterval = null;
    }
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }

    // Clear trackers
    this.trackers.clear();

    this.running = false;
    this.log('Crypto15MLStrategyService stopped');
  }

  /**
   * Check if the service is running
   */
  isRunning(): boolean {
    return this.running;
  }

  /**
   * Get the number of active market trackers
   */
  getTrackerCount(): number {
    return this.trackers.size;
  }

  /**
   * Get information about all active trackers
   */
  getTrackers(): Array<{
    conditionId: string;
    slug: string;
    asset: CryptoAsset;
    endTime: number;
    traded: boolean;
  }> {
    return Array.from(this.trackers.values()).map(t => ({
      conditionId: t.conditionId,
      slug: t.slug,
      asset: t.asset,
      endTime: t.endTime,
      traded: t.traded,
    }));
  }

  // ============================================================================
  // Market Discovery
  // ============================================================================

  /**
   * Predictive scanning: Generate slugs for upcoming markets and check if they exist
   *
   * Runs every 10 minutes with 30-minute lookahead.
   * Market slug pattern: {coin}-updown-15m-{timestamp}
   * Example: btc-updown-15m-1767456000
   */
  async scanUpcomingMarkets(): Promise<void> {
    const now = Date.now();
    const currentWindowStart = Math.floor(now / WINDOW_MS) * WINDOW_MS;

    // Look ahead: current window + 2 future windows (30 minutes total)
    const windowsToCheck = [
      currentWindowStart,
      currentWindowStart + WINDOW_MS,
      currentWindowStart + WINDOW_MS * 2,
    ];

    this.log(`Predictive scan: checking ${windowsToCheck.length} windows for ${SUPPORTED_COINS.length} coins`);

    for (const windowStartMs of windowsToCheck) {
      const windowStartSec = Math.floor(windowStartMs / 1000);

      for (const coin of SUPPORTED_COINS) {
        const slug = `${coin}-updown-15m-${windowStartSec}`;

        // Skip if we already have this tracker
        if (this.hasTrackerForSlug(slug)) {
          continue;
        }

        try {
          // Try to fetch market by slug using MarketService.getMarket()
          // which accepts both condition IDs and slugs
          const unifiedMarket = await this.marketService.getMarket(slug);
          if (unifiedMarket && unifiedMarket.active && !unifiedMarket.closed) {
            // Create a minimal GammaMarket-like object for addMarketTracker
            const market: GammaMarket = {
              id: unifiedMarket.conditionId,
              conditionId: unifiedMarket.conditionId,
              slug: unifiedMarket.slug,
              question: unifiedMarket.question,
              outcomes: unifiedMarket.tokens.map(t => t.outcome),
              outcomePrices: unifiedMarket.tokens.map(t => t.price),
              volume: unifiedMarket.volume,
              liquidity: unifiedMarket.liquidity,
              active: unifiedMarket.active,
              closed: unifiedMarket.closed,
              endDate: unifiedMarket.endDate,
            };
            await this.addMarketTracker(market);
          }
        } catch {
          // Market doesn't exist yet, that's OK for predictive scanning
        }
      }
    }
  }

  /**
   * Reactive scanning: Use MarketService to discover active crypto 15m markets
   *
   * Runs every 1 minute as a safety net to catch any markets missed by predictive scan.
   */
  async scanActiveMarkets(): Promise<void> {
    this.log('Reactive scan: discovering active crypto 15m markets');

    try {
      const markets = await this.marketService.scanCryptoShortTermMarkets({
        minMinutesUntilEnd: 1,
        maxMinutesUntilEnd: 15,
        duration: '15m',
        coin: 'all',
        limit: 50,
      });

      for (const market of markets) {
        // Skip if we already have this tracker
        if (this.trackers.has(market.conditionId)) {
          continue;
        }

        // Verify it's a 15m market by checking slug pattern
        if (this.is15mMarket(market.slug)) {
          await this.addMarketTracker(market);
        }
      }
    } catch (error) {
      this.handleError(error);
    }
  }

  /**
   * Add a market tracker for a discovered market
   *
   * Uses MarketService.getMarket() to fetch complete market data including token IDs.
   */
  private async addMarketTracker(market: GammaMarket): Promise<void> {
    const asset = this.inferAssetFromSlug(market.slug);
    if (!asset) {
      this.log(`Could not infer asset from slug: ${market.slug}`);
      return;
    }

    const symbol = ASSET_TO_SYMBOL[asset];
    if (!this.config.symbols.includes(symbol)) {
      this.log(`Symbol ${symbol} not in configured symbols, skipping`);
      return;
    }

    // Fetch full market data with token IDs
    let unifiedMarket: UnifiedMarket;
    try {
      unifiedMarket = await this.marketService.getMarket(market.conditionId);
    } catch (error) {
      this.log(`Could not fetch full market data for ${market.slug}: ${error}`);
      return;
    }

    // Get token IDs from UnifiedMarket.tokens array
    // Index 0 is typically YES/Up, Index 1 is NO/Down
    if (!unifiedMarket.tokens || unifiedMarket.tokens.length < 2) {
      this.log(`Market ${market.slug} does not have required tokens`);
      return;
    }

    const yesToken = unifiedMarket.tokens[0];
    const noToken = unifiedMarket.tokens[1];

    if (!yesToken?.tokenId || !noToken?.tokenId) {
      this.log(`Could not get token IDs for market ${market.slug}`);
      return;
    }

    const tracker: MarketTracker = {
      conditionId: market.conditionId,
      slug: market.slug,
      asset,
      symbol,
      featureEngine: new Crypto15FeatureEngine(asset),
      endTime: market.endDate.getTime(),
      tokenIds: { yes: yesToken.tokenId, no: noToken.tokenId },
      prices: {
        yes: yesToken.price ?? 0.5,
        no: noToken.price ?? 0.5,
      },
      traded: false,
      createdAt: Date.now(),
    };

    this.trackers.set(market.conditionId, tracker);
    this.log(`Added tracker for ${market.slug} (${asset}), ends at ${new Date(tracker.endTime).toISOString()}`);

    this.emit('marketAdded', {
      conditionId: market.conditionId,
      slug: market.slug,
      asset,
      endTime: tracker.endTime,
    });
  }

  // ============================================================================
  // Price Updates
  // ============================================================================

  /**
   * Subscribe to crypto price updates via WebSocket
   */
  private subscribeToPriceUpdates(): void {
    // Ensure realtime service is connected
    if (!this.realtimeService.isConnected()) {
      this.realtimeService.connect();
    }

    // Subscribe to Chainlink prices (used by Polymarket for crypto markets)
    // The symbols use format like "BTC/USD", "ETH/USD"
    const chainlinkSymbols = this.config.symbols.map(s => {
      const asset = SYMBOL_TO_ASSET[s];
      return `${asset}/USD`;
    });

    this.priceSubscription = this.realtimeService.subscribeCryptoChainlinkPrices(
      chainlinkSymbols,
      {
        onPrice: (price: CryptoPrice) => this.onPriceUpdate(price),
        onError: (error: Error) => this.handleError(error),
      }
    );

    this.log(`Subscribed to crypto prices: ${chainlinkSymbols.join(', ')}`);
  }

  /**
   * Handle price update from WebSocket
   *
   * Routes the price to all relevant feature engines and evaluates signals.
   */
  private onPriceUpdate(priceUpdate: CryptoPrice): void {
    // Convert symbol format (e.g., "BTC/USD" -> "BTC")
    const asset = priceUpdate.symbol.split('/')[0] as CryptoAsset;
    const symbol = ASSET_TO_SYMBOL[asset];

    if (!symbol) {
      return; // Unknown asset
    }

    const price = priceUpdate.price;
    const timestamp = priceUpdate.timestamp;

    // Route price to all trackers for this symbol
    for (const tracker of this.trackers.values()) {
      if (tracker.symbol !== symbol) {
        continue;
      }

      // Ingest price and get features if at minute boundary
      const features = tracker.featureEngine.ingestPrice(price, timestamp);

      if (features) {
        // We're at a minute boundary - evaluate for signal
        this.evaluateSignal(tracker, features);
      }
    }
  }

  // ============================================================================
  // Signal Generation & Execution
  // ============================================================================

  /**
   * Evaluate whether to generate a signal based on features
   *
   * Checks:
   * 1. State minute is in allowed range (default: [0, 1, 2])
   * 2. Model confidence meets threshold (>= 0.70 for YES, <= 0.30 for NO)
   * 3. Entry price is acceptable (<= 0.70)
   * 4. Haven't already traded this market
   */
  private evaluateSignal(tracker: MarketTracker, features: FeatureVector): void {
    // Skip if already traded
    if (tracker.traded) {
      return;
    }

    // Check state minute
    if (!this.config.stateMinutes.includes(features.stateMinute)) {
      return;
    }

    // Get model for this symbol
    const model = this.models.get(tracker.symbol);
    if (!model) {
      this.log(`No model found for symbol ${tracker.symbol}`);
      return;
    }

    // Run prediction
    const featureMap = Crypto15FeatureEngine.toFeatureMap(features);
    const prediction = model.predict(featureMap);

    // Determine signal direction and check thresholds
    let side: 'YES' | 'NO' | null = null;
    let entryPrice = 0;

    if (prediction.probability >= this.config.yesThreshold) {
      side = 'YES';
      entryPrice = tracker.prices.yes;
    } else if (prediction.probability <= this.config.noThreshold) {
      side = 'NO';
      entryPrice = tracker.prices.no;
    }

    if (!side) {
      // No signal - probability in uncertain range
      return;
    }

    // Check entry price cap
    if (entryPrice > this.config.entryPriceCap) {
      this.log(`Entry price ${entryPrice} exceeds cap ${this.config.entryPriceCap} for ${tracker.slug} ${side}`);
      return;
    }

    // Generate signal
    const signal: Signal = {
      conditionId: tracker.conditionId,
      slug: tracker.slug,
      asset: tracker.asset,
      side,
      probability: prediction.probability,
      linearCombination: prediction.linearCombination,
      imputedCount: prediction.imputedCount,
      entryPrice,
      stateMinute: features.stateMinute,
      timestamp: Date.now(),
      features,
    };

    this.log(`Signal generated: ${tracker.slug} ${side} @ ${entryPrice.toFixed(3)} (prob=${prediction.probability.toFixed(3)}, z=${prediction.linearCombination.toFixed(3)})`);

    this.emit('signal', signal);

    // Execute the signal
    this.executeSignal(tracker, signal);
  }

  /**
   * Execute a trading signal by placing a market order
   */
  private async executeSignal(tracker: MarketTracker, signal: Signal): Promise<void> {
    // Mark as traded to prevent duplicate trades
    tracker.traded = true;

    if (this.config.dryRun) {
      this.log(`[DRY RUN] Would execute: ${signal.slug} ${signal.side} @ ${signal.entryPrice.toFixed(3)}`);

      const executionResult: ExecutionResult = {
        signal,
        orderResult: {
          success: true,
          orderId: 'dry-run-' + Date.now(),
        },
        timestamp: Date.now(),
      };

      this.emit('execution', executionResult);
      return;
    }

    try {
      // Determine which token to buy
      const tokenId = signal.side === 'YES' ? tracker.tokenIds.yes : tracker.tokenIds.no;

      // Create market order
      const orderResult = await this.tradingService.createMarketOrder({
        tokenId,
        side: 'BUY',
        amount: this.config.positionSizeUsd,
        orderType: 'FOK', // Fill or Kill
      });

      const executionResult: ExecutionResult = {
        signal,
        orderResult,
        timestamp: Date.now(),
      };

      if (orderResult.success) {
        this.log(`Order executed: ${signal.slug} ${signal.side}, orderId=${orderResult.orderId}`);
      } else {
        this.log(`Order failed: ${signal.slug} ${signal.side}, error=${orderResult.errorMsg}`);
      }

      this.emit('execution', executionResult);
    } catch (error) {
      this.handleError(error);

      const executionResult: ExecutionResult = {
        signal,
        orderResult: {
          success: false,
          errorMsg: error instanceof Error ? error.message : String(error),
        },
        timestamp: Date.now(),
      };

      this.emit('execution', executionResult);
    }
  }

  // ============================================================================
  // Cleanup
  // ============================================================================

  /**
   * Remove trackers for expired markets
   *
   * Runs every 30 seconds.
   */
  private cleanupStaleTrackers(): void {
    const now = Date.now();
    const expiredIds: string[] = [];

    for (const [conditionId, tracker] of this.trackers) {
      // Remove if market has ended
      if (tracker.endTime < now) {
        expiredIds.push(conditionId);
      }
    }

    for (const conditionId of expiredIds) {
      const tracker = this.trackers.get(conditionId);
      if (tracker) {
        this.log(`Removing expired tracker: ${tracker.slug}`);
        this.trackers.delete(conditionId);

        this.emit('marketRemoved', {
          conditionId,
          slug: tracker.slug,
          asset: tracker.asset,
          traded: tracker.traded,
        });
      }
    }

    if (expiredIds.length > 0) {
      this.log(`Cleaned up ${expiredIds.length} expired trackers, ${this.trackers.size} remaining`);
    }
  }

  // ============================================================================
  // Helper Methods
  // ============================================================================

  /**
   * Check if a slug matches the 15m market pattern
   */
  private is15mMarket(slug: string): boolean {
    // Pattern: {coin}-updown-15m-{timestamp}
    return /^(btc|eth|sol|xrp)-updown-15m-\d+$/.test(slug);
  }

  /**
   * Infer crypto asset from market slug
   */
  private inferAssetFromSlug(slug: string): CryptoAsset | null {
    // Extract coin from slug (e.g., "btc-updown-15m-1767456000" -> "btc")
    const match = slug.match(/^(btc|eth|sol|xrp)-updown-/);
    if (match) {
      return COIN_TO_ASSET[match[1]] ?? null;
    }
    return null;
  }

  /**
   * Check if we already have a tracker for a given slug
   */
  private hasTrackerForSlug(slug: string): boolean {
    for (const tracker of this.trackers.values()) {
      if (tracker.slug === slug) {
        return true;
      }
    }
    return false;
  }

  /**
   * Log a message if debug is enabled
   */
  private log(message: string): void {
    if (this.config.debug) {
      console.log(`[Crypto15ML] ${message}`);
    }
  }

  /**
   * Handle an error by emitting it and logging
   */
  private handleError(error: unknown): void {
    const errorObj = error instanceof Error ? error : new Error(String(error));
    this.log(`Error: ${errorObj.message}`);
    this.emit('error', errorObj);
  }
}
